// ============================================
// PROPERTY AGREEMENT FORM - GOOGLE APPS SCRIPT
// ============================================

// Configuration
const CONFIG = {
  ADMIN_USERNAME: 'Admin',
  ADMIN_PASSWORD: 'wellbound!',
  SHEET_NAME: 'Agreements',
  APF_PIN: '1234', // PIN for Hold for Signature and APF access
  COMPANY_INFO: {
    name: 'AMBER COURT AT HOME D/B/A WELLBOUND',
    address: '7424 13th Avenue',
    city: 'Brooklyn, NY 11228',
    phone: 'Tel: 718-530-9880'
  },
  // ADD YOUR ADMIN EMAIL ADDRESSES HERE
  ADMIN_EMAILS: [
    'rafibarides@gmail.com',
    // Add more email addresses as needed
  ],
  // HR EMAIL ADDRESSES (for provisioning notifications)
  HR_EMAILS: [
    // Add HR email addresses here to receive provisioning notifications
    // e.g., 'hr@wellbound.com'
  ]
};

// ============================================
// WEB APP ENTRY POINTS
// ============================================

function doGet(e) {
  const page = e.parameter.page || 'form';
  
  if (page === 'admin') {
    return HtmlService.createHtmlOutput(getAdminLoginPage())
      .setTitle('Admin Login')
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
  }
  
  return HtmlService.createHtmlOutput(getFormPage())
    .setTitle('Property Agreement Form')
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

function doPost(e) {
  try {
    const data = JSON.parse(e.postData.contents);
    const action = data.action;
    
    switch(action) {
      case 'submitForm':
        return ContentService.createTextOutput(JSON.stringify(submitAgreement(data)))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'login':
        return ContentService.createTextOutput(JSON.stringify(adminLogin(data)))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'getAgreements':
        return ContentService.createTextOutput(JSON.stringify(getAllAgreements()))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'searchAgreements':
        return ContentService.createTextOutput(JSON.stringify(searchAgreements(data.query)))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'getStats':
        return ContentService.createTextOutput(JSON.stringify(getStatistics()))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'verifyPin':
        return ContentService.createTextOutput(JSON.stringify(verifyPin(data.pin)))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'holdForSignature':
        return ContentService.createTextOutput(JSON.stringify(holdForSignature(data)))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'getUnsignedAgreements':
        return ContentService.createTextOutput(JSON.stringify(getUnsignedAgreements()))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'updateWithSignatures':
        return ContentService.createTextOutput(JSON.stringify(updateWithSignatures(data)))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'getAgreementByRow':
        return ContentService.createTextOutput(JSON.stringify(getAgreementByRowNumber(data.rowNumber)))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'markDeviceProvisioned':
        return ContentService.createTextOutput(JSON.stringify(markDeviceProvisioned(data.rowNumber, data.provisioned)))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'getProvisionedDevices':
        return ContentService.createTextOutput(JSON.stringify(getProvisionedDevices()))
          .setMimeType(ContentService.MimeType.JSON);
      
      default:
        throw new Error('Invalid action');
    }
  } catch(error) {
    return ContentService.createTextOutput(JSON.stringify({
      success: false,
      error: error.message
    })).setMimeType(ContentService.MimeType.JSON);
  }
}

// ============================================
// SPREADSHEET FUNCTIONS
// ============================================

function initializeSpreadsheet() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = ss.getSheetByName(CONFIG.SHEET_NAME);
  
  if (!sheet) {
    sheet = ss.insertSheet(CONFIG.SHEET_NAME);
    
    // Set up headers
    const headers = [
      'Timestamp',
      'Name',
      'Title',
      'Worker ID',
      'Has Different Training ID',
      'Training Worker ID',
      'Device',
      'Device Name',
      'Portable Charger',
      'Protective Cover',
      'Keyboard/Accessory',
      'Serial Number',
      'Esper Identifier Code',
      'Exchange Device',
      'Returning Device Name',
      'Returning Serial Number',
      'Agreement 1',
      'Agreement 2',
      'Agreement 3',
      'Employee Signature Date',
      'Employee Signature',
      'Supervisor Signature Date',
      'Supervisor Signature',
      'Send Copy to Employee',
      'Employee Email',
      'Provisioned'
    ];
    
    sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
    sheet.getRange(1, 1, 1, headers.length).setFontWeight('bold');
    sheet.setFrozenRows(1);
  }
  
  return sheet;
}

function submitAgreement(data) {
  try {
    const sheet = initializeSpreadsheet();
    
    const row = [
      new Date(),
      data.name || '',
      data.title || '',
      data.workerId || '',
      data.hasDifferentTrainingId || false,
      data.trainingWorkerId || data.workerId || '',
      data.device || false,
      data.deviceName || '',
      data.portableCharger || false,
      data.protectiveCover || false,
      data.keyboard || false,
      data.serialNumber || '',
      data.esperIdentifier || '',
      data.exchangeDevice || false,
      data.returningDeviceName || '',
      data.returningSerial || '',
      data.agreement1 || false,
      data.agreement2 || false,
      data.agreement3 || false,
      data.employeeSignatureDate || new Date(),
      data.employeeSignature || '',
      data.supervisorSignatureDate || new Date(),
      data.supervisorSignature || '',
      data.sendCopyToEmployee || false,
      data.employeeEmail || '',
      false // Provisioned - default false
    ];
    
    sheet.appendRow(row);
    
    const rowNumber = sheet.getLastRow();
    
    // Send emails after successful submission
    try {
      sendNotificationEmails(data, rowNumber);
    } catch(emailError) {
      Logger.log('Email sending failed: ' + emailError.message);
      // Don't fail the submission if email fails
    }
    
    return {
      success: true,
      message: 'Agreement submitted successfully',
      rowNumber: rowNumber
    };
  } catch(error) {
    return {
      success: false,
      error: error.message
    };
  }
}

function getAllAgreements() {
  try {
    const sheet = initializeSpreadsheet();
    const data = sheet.getDataRange().getValues();
    
    if (data.length <= 1) {
      return { success: true, agreements: [] };
    }
    
    const headers = data[0];
    const agreements = [];
    
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const agreement = {};
      
      headers.forEach((header, index) => {
        agreement[header] = row[index];
      });
      
      agreement.rowNumber = i + 1;
      agreements.push(agreement);
    }
    
    return {
      success: true,
      agreements: agreements.reverse() // Most recent first
    };
  } catch(error) {
    return {
      success: false,
      error: error.message
    };
  }
}

function searchAgreements(query) {
  try {
    const allData = getAllAgreements();
    
    if (!allData.success) {
      return allData;
    }
    
    const searchTerm = query.toLowerCase();
    const filtered = allData.agreements.filter(agreement => {
      return (
        (agreement.Name && agreement.Name.toString().toLowerCase().includes(searchTerm)) ||
        (agreement['Worker ID'] && agreement['Worker ID'].toString().toLowerCase().includes(searchTerm)) ||
        (agreement['Serial Number'] && agreement['Serial Number'].toString().toLowerCase().includes(searchTerm)) ||
        (agreement['Esper Identifier Code'] && agreement['Esper Identifier Code'].toString().toLowerCase().includes(searchTerm))
      );
    });
    
    return {
      success: true,
      agreements: filtered
    };
  } catch(error) {
    return {
      success: false,
      error: error.message
    };
  }
}

function getStatistics() {
  try {
    const allData = getAllAgreements();
    
    if (!allData.success) {
      return allData;
    }
    
    const agreements = allData.agreements;
    
    // Count Esper IDs (non-empty)
    const esperIds = agreements.filter(a => 
      a['Esper Identifier Code'] && a['Esper Identifier Code'].toString().trim() !== ''
    ).length;
    
    return {
      success: true,
      stats: {
        totalAgreements: agreements.length,
        esperIds: esperIds,
        lastSubmission: agreements.length > 0 ? agreements[0].Timestamp : null
      }
    };
  } catch(error) {
    return {
      success: false,
      error: error.message
    };
  }
}

// ============================================
// AUTHENTICATION
// ============================================

function adminLogin(data) {
  const username = data.username;
  const password = data.password;
  
  if (username === CONFIG.ADMIN_USERNAME && password === CONFIG.ADMIN_PASSWORD) {
    return {
      success: true,
      message: 'Login successful'
    };
  }
  
  return {
    success: false,
    error: 'Invalid credentials'
  };
}

function verifyPin(pin) {
  if (pin === CONFIG.APF_PIN) {
    return {
      success: true,
      message: 'PIN verified'
    };
  }
  
  return {
    success: false,
    error: 'Invalid PIN'
  };
}

// ============================================
// HOLD FOR SIGNATURE FUNCTIONS
// ============================================

function holdForSignature(data) {
  try {
    const sheet = initializeSpreadsheet();
    
    // Create row without signatures
    const row = [
      new Date(),
      data.name || '',
      data.title || '',
      data.workerId || '',
      data.hasDifferentTrainingId || false,
      data.trainingWorkerId || data.workerId || '',
      data.device || false,
      data.deviceName || '',
      data.portableCharger || false,
      data.protectiveCover || false,
      data.keyboard || false,
      data.serialNumber || '',
      data.esperIdentifier || '',
      data.exchangeDevice || false,
      data.returningDeviceName || '',
      data.returningSerial || '',
      data.agreement1 || false,
      data.agreement2 || false,
      data.agreement3 || false,
      '', // Employee Signature Date - empty
      '', // Employee Signature - empty
      '', // Supervisor Signature Date - empty
      '', // Supervisor Signature - empty
      false, // Send Copy to Employee
      '', // Employee Email
      false // Provisioned - default false
    ];
    
    sheet.appendRow(row);
    const rowNumber = sheet.getLastRow();
    
    return {
      success: true,
      message: 'Form held for signature',
      rowNumber: rowNumber
    };
  } catch(error) {
    return {
      success: false,
      error: error.message
    };
  }
}

function getUnsignedAgreements() {
  try {
    const sheet = initializeSpreadsheet();
    const data = sheet.getDataRange().getValues();
    
    if (data.length <= 1) {
      return { success: true, agreements: [] };
    }
    
    const headers = data[0];
    const unsigned = [];
    
    // Find column indices
    const empSigIndex = headers.indexOf('Employee Signature');
    const supSigIndex = headers.indexOf('Supervisor Signature');
    
    // If signature columns don't exist, return empty (sheet may not be set up yet)
    if (empSigIndex === -1 || supSigIndex === -1) {
      Logger.log('Signature columns not found. Headers: ' + headers.join(', '));
      return { success: true, agreements: [] };
    }
    
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      
      // Check if both signatures are empty
      const empSig = row[empSigIndex];
      const supSig = row[supSigIndex];
      
      if ((!empSig || empSig.toString().trim() === '') && 
          (!supSig || supSig.toString().trim() === '')) {
        const agreement = {};
        headers.forEach((header, index) => {
          agreement[header] = row[index];
        });
        agreement.rowNumber = i + 1;
        unsigned.push(agreement);
      }
    }
    
    return {
      success: true,
      agreements: unsigned.reverse() // Most recent first
    };
  } catch(error) {
    Logger.log('getUnsignedAgreements error: ' + error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

function getAgreementByRowNumber(rowNumber) {
  try {
    if (!rowNumber) {
      return { success: false, error: 'Row number is required' };
    }
    
    const sheet = initializeSpreadsheet();
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    // Row number is 1-indexed (row 1 is headers, row 2 is first data row)
    const rowIndex = parseInt(rowNumber) - 1;
    
    if (rowIndex < 1 || rowIndex >= data.length) {
      return { success: false, error: 'Agreement not found' };
    }
    
    const row = data[rowIndex];
    const agreement = {};
    
    headers.forEach((header, index) => {
      agreement[header] = row[index];
    });
    agreement.rowNumber = parseInt(rowNumber);
    
    return {
      success: true,
      agreement: agreement
    };
  } catch(error) {
    Logger.log('getAgreementByRowNumber error: ' + error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

function updateWithSignatures(data) {
  try {
    const sheet = initializeSpreadsheet();
    const allData = sheet.getDataRange().getValues();
    const headers = allData[0];
    
    // Find column indices (0-indexed from headers array)
    const nameIndex = headers.indexOf('Name');
    const workerIdIndex = headers.indexOf('Worker ID');
    const empSigIndex = headers.indexOf('Employee Signature');
    const supSigIndex = headers.indexOf('Supervisor Signature');
    const empSigDateIndex = headers.indexOf('Employee Signature Date');
    const supSigDateIndex = headers.indexOf('Supervisor Signature Date');
    const sendCopyIndex = headers.indexOf('Send Copy to Employee');
    const emailIndex = headers.indexOf('Employee Email');
    
    // Additional columns that may need updating (filled by IT after HR creates request)
    const deviceNameIndex = headers.indexOf('Device Name');
    const serialNumberIndex = headers.indexOf('Serial Number');
    const esperIdentifierIndex = headers.indexOf('Esper Identifier Code');
    const trainingWorkerIdIndex = headers.indexOf('Training Worker ID');
    
    // Validate that required columns exist
    const requiredColumns = {
      'Name': nameIndex,
      'Worker ID': workerIdIndex,
      'Employee Signature': empSigIndex,
      'Supervisor Signature': supSigIndex,
      'Employee Signature Date': empSigDateIndex,
      'Supervisor Signature Date': supSigDateIndex
    };
    
    for (const [colName, colIndex] of Object.entries(requiredColumns)) {
      if (colIndex === -1) {
        Logger.log('Missing column: ' + colName + '. Headers found: ' + headers.join(', '));
        return {
          success: false,
          error: 'Spreadsheet missing required column: ' + colName
        };
      }
    }
    
    // Find the matching unsigned row
    let matchingRow = -1;
    
    // PRIORITY 1: If rowNumber is provided (from barcode scan), use it directly
    if (data.rowNumber) {
      const rowIndex = parseInt(data.rowNumber);
      if (rowIndex >= 2 && rowIndex <= allData.length) {
        const row = allData[rowIndex - 1];
        const empSig = row[empSigIndex];
        const supSig = row[supSigIndex];
        
        // Verify the row is unsigned
        if ((!empSig || empSig.toString().trim() === '') && 
            (!supSig || supSig.toString().trim() === '')) {
          matchingRow = rowIndex;
          Logger.log('Matched by rowNumber: ' + matchingRow);
        } else {
          Logger.log('Row ' + rowIndex + ' is already signed');
        }
      }
    }
    
    // PRIORITY 2: Fall back to name + workerId matching (for non-barcode submissions)
    if (matchingRow === -1) {
      for (let i = 1; i < allData.length; i++) {
        const row = allData[i];
        const empSig = row[empSigIndex];
        const supSig = row[supSigIndex];
        
        // Check if row is unsigned
        if ((!empSig || empSig.toString().trim() === '') && 
            (!supSig || supSig.toString().trim() === '')) {
          // Check if name and workerId match
          if (row[nameIndex] === data.name && 
              row[workerIdIndex].toString() === data.workerId.toString()) {
            matchingRow = i + 1; // Sheet rows are 1-indexed
            Logger.log('Matched by name + workerId: ' + matchingRow);
            break;
          }
        }
      }
    }
    
    if (matchingRow === -1) {
      return {
        success: false,
        error: 'No matching unsigned agreement found'
      };
    }
    
    // Update the row with signatures (column indices are 0-based, getRange needs 1-based)
    sheet.getRange(matchingRow, empSigDateIndex + 1).setValue(data.employeeSignatureDate || new Date());
    sheet.getRange(matchingRow, empSigIndex + 1).setValue(data.employeeSignature || '');
    sheet.getRange(matchingRow, supSigDateIndex + 1).setValue(data.supervisorSignatureDate || new Date());
    sheet.getRange(matchingRow, supSigIndex + 1).setValue(data.supervisorSignature || '');
    
    // Update Worker ID if provided (IT fills this in after HR creates request)
    if (data.workerId && workerIdIndex !== -1) {
      sheet.getRange(matchingRow, workerIdIndex + 1).setValue(data.workerId);
    }
    
    // Update Training Worker ID if provided
    if (data.trainingWorkerId && trainingWorkerIdIndex !== -1) {
      sheet.getRange(matchingRow, trainingWorkerIdIndex + 1).setValue(data.trainingWorkerId);
    }
    
    // Update device info if provided (IT fills these in)
    if (data.deviceName && deviceNameIndex !== -1) {
      sheet.getRange(matchingRow, deviceNameIndex + 1).setValue(data.deviceName);
    }
    if (data.serialNumber && serialNumberIndex !== -1) {
      sheet.getRange(matchingRow, serialNumberIndex + 1).setValue(data.serialNumber);
    }
    if (data.esperIdentifier && esperIdentifierIndex !== -1) {
      sheet.getRange(matchingRow, esperIdentifierIndex + 1).setValue(data.esperIdentifier);
    }
    
    // Only update email columns if they exist (they might be missing in older sheets)
    if (sendCopyIndex !== -1) {
      sheet.getRange(matchingRow, sendCopyIndex + 1).setValue(data.sendCopyToEmployee || false);
    }
    if (emailIndex !== -1) {
      sheet.getRange(matchingRow, emailIndex + 1).setValue(data.employeeEmail || '');
    }
    
    // Clear the Provisioned flag once signed (device is picked up)
    const provisionedIndex = headers.indexOf('Provisioned');
    if (provisionedIndex !== -1) {
      sheet.getRange(matchingRow, provisionedIndex + 1).setValue(false);
    }
    
    // Send emails after successful update
    try {
      sendNotificationEmails(data, matchingRow);
    } catch(emailError) {
      Logger.log('Email sending failed: ' + emailError.message);
    }
    
    return {
      success: true,
      message: 'Agreement updated with signatures',
      rowNumber: matchingRow
    };
  } catch(error) {
    Logger.log('updateWithSignatures error: ' + error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

// ============================================
// DEVICE PROVISIONING FUNCTIONS
// ============================================

/**
 * Mark a device as provisioned (ready for pickup)
 * This notifies HR that the device is ready
 */
function markDeviceProvisioned(rowNumber, provisioned) {
  try {
    if (!rowNumber) {
      return { success: false, error: 'Row number is required' };
    }
    
    const sheet = initializeSpreadsheet();
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    
    // Find or create Provisioned column
    let provisionedIndex = headers.indexOf('Provisioned');
    
    if (provisionedIndex === -1) {
      // Add the Provisioned column if it doesn't exist
      provisionedIndex = headers.length;
      sheet.getRange(1, provisionedIndex + 1).setValue('Provisioned');
    }
    
    // Validate row exists
    const rowIndex = parseInt(rowNumber);
    if (rowIndex < 2 || rowIndex > sheet.getLastRow()) {
      return { success: false, error: 'Invalid row number' };
    }
    
    // Get the agreement data for notification
    const rowData = sheet.getRange(rowIndex, 1, 1, headers.length).getValues()[0];
    const agreement = {};
    headers.forEach((header, index) => {
      agreement[header] = rowData[index];
    });
    agreement.rowNumber = rowIndex;
    
    // Update the Provisioned status
    const newStatus = provisioned !== false; // Default to true if not explicitly false
    sheet.getRange(rowIndex, provisionedIndex + 1).setValue(newStatus);
    
    // Send notification to HR if marking as provisioned
    if (newStatus) {
      try {
        sendProvisionedNotification(agreement);
      } catch(emailError) {
        Logger.log('HR notification failed: ' + emailError.message);
        // Don't fail the operation if email fails
      }
    }
    
    return {
      success: true,
      message: newStatus ? 'Device marked as provisioned' : 'Device unmarked as provisioned',
      rowNumber: rowIndex,
      provisioned: newStatus
    };
  } catch(error) {
    Logger.log('markDeviceProvisioned error: ' + error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Get all provisioned devices that are still unsigned (ready for pickup)
 */
function getProvisionedDevices() {
  try {
    const sheet = initializeSpreadsheet();
    const data = sheet.getDataRange().getValues();
    
    if (data.length <= 1) {
      return { success: true, devices: [] };
    }
    
    const headers = data[0];
    const devices = [];
    
    // Find column indices
    const empSigIndex = headers.indexOf('Employee Signature');
    const supSigIndex = headers.indexOf('Supervisor Signature');
    const provisionedIndex = headers.indexOf('Provisioned');
    
    // If required columns don't exist, return empty
    if (empSigIndex === -1 || supSigIndex === -1) {
      Logger.log('Required columns not found');
      return { success: true, devices: [] };
    }
    
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      
      // Check if provisioned
      const isProvisioned = provisionedIndex !== -1 && 
        (row[provisionedIndex] === true || row[provisionedIndex] === 'TRUE');
      
      if (!isProvisioned) continue;
      
      // Check if still unsigned (no signatures)
      const empSig = row[empSigIndex];
      const supSig = row[supSigIndex];
      const isUnsigned = (!empSig || empSig.toString().trim() === '') && 
                         (!supSig || supSig.toString().trim() === '');
      
      // Only include if provisioned AND still unsigned
      if (isUnsigned) {
        const device = {};
        headers.forEach((header, index) => {
          device[header] = row[index];
        });
        device.rowNumber = i + 1;
        devices.push(device);
      }
    }
    
    return {
      success: true,
      devices: devices.reverse() // Most recent first
    };
  } catch(error) {
    Logger.log('getProvisionedDevices error: ' + error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Send notification to HR when a device is marked as provisioned
 */
function sendProvisionedNotification(agreement) {
  // Skip if no HR emails configured
  if (!CONFIG.HR_EMAILS || CONFIG.HR_EMAILS.length === 0) {
    Logger.log('No HR emails configured for provisioning notifications');
    return;
  }
  
  const subject = `Device Ready for Pickup - ${agreement.Name || 'Unknown'}`;
  
  const body = `
A device has been provisioned and is ready for pickup.

EMPLOYEE INFORMATION:
Name: ${agreement.Name || 'N/A'}
Title: ${agreement.Title || 'N/A'}
Worker ID: ${agreement['Worker ID'] || 'N/A'}

DEVICE DETAILS:
Device: ${agreement['Device Name'] || 'N/A'}
Serial Number: ${agreement['Serial Number'] || 'N/A'}
Esper ID: ${agreement['Esper Identifier Code'] || 'N/A'}

This device is ready for the employee to pick up and sign the property agreement.

---
${CONFIG.COMPANY_INFO.name}
${CONFIG.COMPANY_INFO.address}
${CONFIG.COMPANY_INFO.city}
${CONFIG.COMPANY_INFO.phone}
  `.trim();
  
  CONFIG.HR_EMAILS.forEach(email => {
    try {
      MailApp.sendEmail({
        to: email,
        subject: subject,
        body: body
      });
      Logger.log('HR notification sent to: ' + email);
    } catch(e) {
      Logger.log('Failed to send HR notification to ' + email + ': ' + e.message);
    }
  });
}

// ============================================
// EMAIL FUNCTIONS
// ============================================

function sendNotificationEmails(agreementData, rowNumber) {
  Logger.log('Starting email send process for: ' + agreementData.name);
  
  const pdfResult = generatePDFBlob(agreementData);
  
  if (!pdfResult.success) {
    Logger.log('PDF generation failed: ' + pdfResult.error);
    throw new Error('Failed to generate PDF: ' + pdfResult.error);
  }
  
  Logger.log('PDF generated successfully');
  
  const pdfBytes = pdfResult.blob.getBytes();
  const filename = pdfResult.filename;
  
  // Send to admin emails
  if (CONFIG.ADMIN_EMAILS && CONFIG.ADMIN_EMAILS.length > 0) {
    const adminSubject = `New Property Agreement Submitted - ${agreementData.name}`;
    const adminBody = generateAdminEmailBody(agreementData);
    
    Logger.log('Sending to ' + CONFIG.ADMIN_EMAILS.length + ' admin email(s)');
    
    CONFIG.ADMIN_EMAILS.forEach(email => {
      try {
        // Create a fresh blob for each email
        const attachment = Utilities.newBlob(pdfBytes, 'application/pdf', filename);
        
        MailApp.sendEmail({
          to: email,
          subject: adminSubject,
          body: adminBody,
          attachments: [attachment]
        });
        Logger.log('Successfully sent to admin: ' + email);
      } catch(e) {
        Logger.log('Failed to send to admin email ' + email + ': ' + e.message);
      }
    });
  } else {
    Logger.log('No admin emails configured');
  }
  
  // Send to employee if requested
  if (agreementData.sendCopyToEmployee && agreementData.employeeEmail) {
    const employeeSubject = 'Your Property Agreement - WELLBOUND';
    const employeeBody = generateEmployeeEmailBody(agreementData);
    
    try {
      // Create a fresh blob for employee email
      const attachment = Utilities.newBlob(pdfBytes, 'application/pdf', filename);
      
      MailApp.sendEmail({
        to: agreementData.employeeEmail,
        subject: employeeSubject,
        body: employeeBody,
        attachments: [attachment]
      });
      Logger.log('Successfully sent to employee: ' + agreementData.employeeEmail);
    } catch(e) {
      Logger.log('Failed to send to employee email: ' + e.message);
    }
  }
  
  Logger.log('Email send process completed');
}

function generateAdminEmailBody(data) {
  const devicesList = [];
  if (data.device) devicesList.push(data.deviceName || 'Device');
  if (data.portableCharger) devicesList.push('Portable Charger');
  if (data.protectiveCover) devicesList.push('Protective Cover');
  if (data.keyboard) devicesList.push('Keyboard/Accessory');
  
  return `
A new Property Agreement has been submitted.

EMPLOYEE INFORMATION:
Name: ${data.name || 'N/A'}
Title: ${data.title || 'N/A'}
Worker ID: ${data.workerId || 'N/A'}
${data.hasDifferentTrainingId ? 'Training Worker ID: ' + (data.trainingWorkerId || 'N/A') + '\n' : ''}

PROPERTY DETAILS:
Devices Received: ${devicesList.join(', ') || 'None'}
Serial Number: ${data.serialNumber || 'N/A'}
Esper Identifier Code: ${data.esperIdentifier || 'N/A'}

${data.exchangeDevice ? 'EXCHANGE INFORMATION:\nReturning Device: ' + (data.returningDeviceName || 'N/A') + '\nReturning Serial: ' + (data.returningSerial || 'N/A') + '\n' : ''}

Submission Date: ${new Date().toLocaleString()}

Please see the attached PDF for the complete signed agreement.

---
${CONFIG.COMPANY_INFO.name}
${CONFIG.COMPANY_INFO.address}
${CONFIG.COMPANY_INFO.city}
${CONFIG.COMPANY_INFO.phone}
  `.trim();
}

function generateEmployeeEmailBody(data) {
  return `
Dear ${data.name},

Thank you for completing your Property Agreement form with WELLBOUND.

Please find attached a copy of your signed Property Agreement for your records. This document confirms the property you have received and your acknowledgment of the terms and conditions.

If you have any questions or concerns, please contact your supervisor or the Human Resources department.

Best regards,
${CONFIG.COMPANY_INFO.name}
${CONFIG.COMPANY_INFO.address}
${CONFIG.COMPANY_INFO.city}
${CONFIG.COMPANY_INFO.phone}
  `.trim();
}

// ============================================
// PDF GENERATION
// ============================================

function generatePDF(rowNumber) {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(CONFIG.SHEET_NAME);
    const data = sheet.getRange(rowNumber, 1, 1, sheet.getLastColumn()).getValues()[0];
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    
    const agreement = {};
    headers.forEach((header, index) => {
      agreement[header] = data[index];
    });
    
    // Create HTML for PDF
    const html = generatePDFHTML(agreement);
    
    // Convert to PDF
    const blob = Utilities.newBlob(html, 'text/html', 'agreement.html').getAs('application/pdf');
    
    return {
      success: true,
      pdf: Utilities.base64Encode(blob.getBytes()),
      filename: `Agreement_${agreement.Name}_${agreement['Worker ID']}.pdf`
    };
  } catch(error) {
    return {
      success: false,
      error: error.message
    };
  }
}

function generatePDFBlob(agreementData) {
  try {
    // Create HTML for PDF
    const html = generatePDFHTML(agreementData);
    
    // Convert to PDF
    const blob = Utilities.newBlob(html, 'text/html', 'agreement.html').getAs('application/pdf');
    
    const filename = `Agreement_${agreementData.name}_${agreementData.workerId}.pdf`;
    
    return {
      success: true,
      blob: blob,
      filename: filename
    };
  } catch(error) {
    return {
      success: false,
      error: error.message
    };
  }
}

function generatePDFHTML(agreement) {
  const devicesList = [];
  if (agreement.device || agreement.Device) devicesList.push(agreement.deviceName || agreement['Device Name'] || 'Device');
  if (agreement.portableCharger || agreement['Portable Charger']) devicesList.push('Portable Charger');
  if (agreement.protectiveCover || agreement['Protective Cover']) devicesList.push('Protective Cover');
  if (agreement.keyboard || agreement['Keyboard/Accessory']) devicesList.push('Keyboard/Accessory');
  
  const name = agreement.name || agreement.Name || '';
  const title = agreement.title || agreement.Title || '';
  const workerId = agreement.workerId || agreement['Worker ID'] || '';
  const hasDifferentTrainingId = agreement.hasDifferentTrainingId || agreement['Has Different Training ID'];
  const trainingWorkerId = agreement.trainingWorkerId || agreement['Training Worker ID'] || '';
  const serialNumber = agreement.serialNumber || agreement['Serial Number'] || '';
  const esperIdentifier = agreement.esperIdentifier || agreement['Esper Identifier Code'] || '';
  const exchangeDevice = agreement.exchangeDevice || agreement['Exchange Device'];
  const returningDeviceName = agreement.returningDeviceName || agreement['Returning Device Name'] || '';
  const returningSerial = agreement.returningSerial || agreement['Returning Serial Number'] || '';
  const employeeSignature = agreement.employeeSignature || agreement['Employee Signature'] || '';
  const employeeSignatureDate = agreement.employeeSignatureDate || agreement['Employee Signature Date'];
  const supervisorSignature = agreement.supervisorSignature || agreement['Supervisor Signature'] || '';
  const supervisorSignatureDate = agreement.supervisorSignatureDate || agreement['Supervisor Signature Date'];
  
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        body {
          font-family: Arial, sans-serif;
          padding: 30px;
          color: #333;
          font-size: 12px;
        }
        .header {
          text-align: center;
          margin-bottom: 20px;
        }
        .company-info {
          text-align: center;
          font-size: 11px;
          margin-top: 8px;
        }
        .title {
          font-size: 18px;
          font-weight: bold;
          margin: 15px 0;
          color: #3E0E30;
        }
        .field {
          margin: 10px 0;
        }
        .field-label {
          font-weight: bold;
          color: #3E0E30;
        }
        .signature-section {
          margin-top: 25px;
        }
        .signatures-row {
          display: flex;
          gap: 30px;
        }
        .signature-box {
          flex: 1;
          padding: 8px 0;
        }
        .signature-label {
          font-weight: bold;
          margin-bottom: 5px;
        }
        .signature-line {
          border-bottom: 1px solid #333;
          min-height: 50px;
          margin-bottom: 5px;
        }
        .signature-line img {
          max-height: 48px;
        }
        .signature-date {
          font-size: 11px;
        }
        .footer {
          margin-top: 20px;
          text-align: center;
          font-size: 10px;
          color: #666;
        }
      </style>
    </head>
    <body>
      <div class="header">
        <h1 style="margin: 0; font-size: 20px;">PROPERTY AGREEMENT FORM</h1>
        <div class="company-info">
          <div>${CONFIG.COMPANY_INFO.name}</div>
          <div>${CONFIG.COMPANY_INFO.address}</div>
          <div>${CONFIG.COMPANY_INFO.city}</div>
          <div>${CONFIG.COMPANY_INFO.phone}</div>
        </div>
      </div>
      
      <div class="field">
        <span class="field-label">Name:</span> ${name}
      </div>
      
      <div class="field">
        <span class="field-label">Title:</span> ${title}
      </div>
      
      <div class="field">
        <span class="field-label">Worker ID:</span> ${workerId}
      </div>
      
      ${hasDifferentTrainingId ? `
      <div class="field">
        <span class="field-label">Training Worker ID:</span> ${trainingWorkerId}
      </div>
      ` : ''}
      
      <div class="title">Acknowledgement of Received Property</div>
      
      <div class="field">
        <span class="field-label">Devices Received:</span>
        <ul style="margin: 5px 0 5px 20px; padding: 0;">
          ${devicesList.map(device => `<li>${device}</li>`).join('')}
        </ul>
      </div>
      
      ${serialNumber ? `
      <div class="field">
        <span class="field-label">Serial Number:</span> ${serialNumber}
      </div>
      ` : ''}
      
      ${esperIdentifier ? `
      <div class="field">
        <span class="field-label">Esper Identifier Code:</span> ${esperIdentifier}
      </div>
      ` : ''}
      
      ${exchangeDevice ? `
      <div class="field">
        <span class="field-label">Exchange Information:</span>
        <div style="margin-left: 10px;">Returning Device: ${returningDeviceName}</div>
        <div style="margin-left: 10px;">Returning Serial: ${returningSerial}</div>
      </div>
      ` : ''}
      
      <div class="title">Agreements</div>
      
      <div class="field" style="font-size: 11px;">
        ☑ I agree to maintain all Agency property in working condition, and to notify the Agency in the event that the property malfunctions in any way, or if the property is lost or stolen.
      </div>
      
      <div class="field" style="font-size: 11px;">
        ☑ If there are any items which I do not need, these will be returned immediately to my Supervisor.
      </div>
      
      <div class="field" style="font-size: 11px;">
        ☑ I have been advised by my Supervisor / Human Resources, that it is my responsibility to return all property to the Agency upon termination of the engagement between myself and the Agency.
      </div>
      
      <div class="signature-section">
        <div class="signatures-row">
          <div class="signature-box">
            <div class="signature-label">Employee Signature</div>
            <div class="signature-line">
              ${employeeSignature ? `<img src="${svgToDataUrl(employeeSignature)}" />` : ''}
            </div>
            <div class="signature-date">Date: ${formatDate(employeeSignatureDate)}</div>
          </div>
          <div class="signature-box">
            <div class="signature-label">Supervisor Signature</div>
            <div class="signature-line">
              ${supervisorSignature ? `<img src="${svgToDataUrl(supervisorSignature)}" />` : ''}
            </div>
            <div class="signature-date">Date: ${formatDate(supervisorSignatureDate)}</div>
          </div>
        </div>
      </div>
      
      <div class="footer">
        Generated on ${formatDate(new Date())}
      </div>
    </body>
    </html>
  `;
}

function svgToDataUrl(svgPath) {
  if (!svgPath || svgPath.trim() === '') return '';
  
  const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 100">
    <path d="${svgPath}" stroke="#000" stroke-width="2" fill="none" />
  </svg>`;
  
  return 'data:image/svg+xml;base64,' + Utilities.base64Encode(svg);
}

function formatDate(date) {
  if (!date) return '';
  const d = new Date(date);
  return `${d.getMonth() + 1}/${d.getDate()}/${d.getFullYear()}`;
}

// ============================================
// HTML TEMPLATES (Placeholder - Frontend to be built)
// ============================================

function getFormPage() {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <title>Property Agreement Form</title>
      <style>
        body { font-family: Arial; padding: 20px; text-align: center; }
      </style>
    </head>
    <body>
      <h1>Property Agreement Form</h1>
      <p>This is a placeholder. Build your frontend to connect to this endpoint.</p>
      <p>Web App URL: ${ScriptApp.getService().getUrl()}</p>
      <p>Use POST requests with action parameter to interact with the backend.</p>
    </body>
    </html>
  `;
}

function getAdminLoginPage() {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <title>Admin Login</title>
      <style>
        body { font-family: Arial; padding: 20px; text-align: center; }
      </style>
    </head>
    <body>
      <h1>Admin Portal</h1>
      <p>This is a placeholder. Build your admin frontend to connect to this endpoint.</p>
      <p>Web App URL: ${ScriptApp.getService().getUrl()}</p>
    </body>
    </html>
  `;
}

// ============================================
// UTILITY FUNCTIONS FOR TESTING
// ============================================

function testSubmit() {
  const testData = {
    action: 'submitForm',
    name: 'John Doe',
    title: 'RN – Registered Nurse',
    workerId: '12345',
    hasDifferentTrainingId: false,
    trainingWorkerId: '12345',
    device: true,
    deviceName: 'Lenovo Tab',
    portableCharger: true,
    protectiveCover: true,
    keyboard: false,
    serialNumber: 'SN123456',
    esperIdentifier: 'ESP789',
    exchangeDevice: false,
    agreement1: true,
    agreement2: true,
    agreement3: true,
    employeeSignatureDate: new Date(),
    employeeSignature: 'M 10 50 L 100 50',
    supervisorSignatureDate: new Date(),
    supervisorSignature: 'M 10 50 L 100 50',
    sendCopyToEmployee: true,
    employeeEmail: 'john.doe@example.com'
  };
  
  Logger.log(submitAgreement(testData));
}

function testGetAgreements() {
  Logger.log(getAllAgreements());
}

function testSearch() {
  Logger.log(searchAgreements('john'));
}

function testStats() {
  Logger.log(getStatistics());
}

// Test email sending directly (run this to verify emails work)
function testEmailSending() {
  Logger.log('=== EMAIL TEST STARTED ===');
  Logger.log('Admin emails configured: ' + JSON.stringify(CONFIG.ADMIN_EMAILS));
  
  // Check remaining email quota
  const remainingQuota = MailApp.getRemainingDailyQuota();
  Logger.log('Remaining daily email quota: ' + remainingQuota);
  
  if (remainingQuota <= 0) {
    Logger.log('ERROR: No email quota remaining!');
    return;
  }
  
  const testData = {
    name: 'TEST - Email Test',
    title: 'Test Title',
    workerId: '00000',
    device: true,
    deviceName: 'Test Device',
    portableCharger: false,
    protectiveCover: false,
    keyboard: false,
    serialNumber: 'TEST-SERIAL',
    esperIdentifier: 'TEST-ESPER',
    exchangeDevice: false,
    employeeSignature: 'M 10 50 L 100 50 L 150 30',
    employeeSignatureDate: new Date(),
    supervisorSignature: 'M 10 50 L 100 50 L 150 70',
    supervisorSignatureDate: new Date()
  };
  
  try {
    sendNotificationEmails(testData, 0);
    Logger.log('=== EMAIL TEST COMPLETED ===');
    Logger.log('Check your inbox at: ' + CONFIG.ADMIN_EMAILS.join(', '));
  } catch(e) {
    Logger.log('=== EMAIL TEST FAILED ===');
    Logger.log('Error: ' + e.message);
    Logger.log('Stack: ' + e.stack);
  }
}

// Test provisioning functions
function testMarkProvisioned() {
  Logger.log('=== PROVISIONING TEST ===');
  
  // Get the last row number for testing
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(CONFIG.SHEET_NAME);
  if (!sheet) {
    Logger.log('Sheet not found');
    return;
  }
  
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) {
    Logger.log('No data rows to test with');
    return;
  }
  
  // Test marking as provisioned
  Logger.log('Marking row ' + lastRow + ' as provisioned...');
  const result = markDeviceProvisioned(lastRow, true);
  Logger.log('Result: ' + JSON.stringify(result));
  
  // Test getting provisioned devices
  Logger.log('Getting provisioned devices...');
  const devices = getProvisionedDevices();
  Logger.log('Provisioned devices: ' + JSON.stringify(devices));
}

/**
 * Migration utility: Add Provisioned column to existing spreadsheet
 * Run this once if you have an existing spreadsheet without the Provisioned column
 */
function addProvisionedColumn() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(CONFIG.SHEET_NAME);
  if (!sheet) {
    Logger.log('Sheet not found');
    return;
  }
  
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  if (headers.indexOf('Provisioned') !== -1) {
    Logger.log('Provisioned column already exists');
    return;
  }
  
  // Add the header
  const newColIndex = headers.length + 1;
  sheet.getRange(1, newColIndex).setValue('Provisioned');
  
  // Set all existing rows to FALSE
  const lastRow = sheet.getLastRow();
  if (lastRow > 1) {
    const range = sheet.getRange(2, newColIndex, lastRow - 1, 1);
    const values = [];
    for (let i = 0; i < lastRow - 1; i++) {
      values.push([false]);
    }
    range.setValues(values);
  }
  
  Logger.log('Provisioned column added successfully');
}