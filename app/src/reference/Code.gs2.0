// ============================================
// PROPERTY AGREEMENT FORM - GOOGLE APPS SCRIPT
// ============================================

// Configuration
const CONFIG = {
  ADMIN_USERNAME: 'Admin',
  ADMIN_PASSWORD: 'wellbound!',
  SHEET_NAME: 'Agreements',
  RETRIEVAL_SHEET_NAME: 'Retrievals',
  APF_PIN: '1234', // PIN for Hold for Signature and APF access
  // Retrieval Program Stages
  RETRIEVAL_STAGES: {
    1: 'Terminated/Inactive',
    2: 'Text Sent to Staff',
    3: 'Staff Called',
    4: 'Final Follow Up',
    5: 'Scheduled Dropoff',
    6: 'Awaiting Mailback',
    7: 'Device Returned',
    8: 'Remotely Offboarded'
  },
  COMPANY_INFO: {
    name: 'AMBER COURT AT HOME D/B/A WELLBOUND',
    address: '7424 13th Avenue',
    city: 'Brooklyn, NY 11228',
    phone: 'Tel: 718-530-9880'
  },
  // ADD YOUR ADMIN EMAIL ADDRESSES HERE
  ADMIN_EMAILS: [
    'rafibarides@gmail.com',
    // Add more email addresses as needed
  ],
  // HR EMAIL ADDRESSES (for provisioning notifications)
  HR_EMAILS: [
    // Add HR email addresses here to receive provisioning notifications
    // e.g., 'hr@wellbound.com'
  ]
};

// ============================================
// WEB APP ENTRY POINTS
// ============================================

function doGet(e) {
  const page = e.parameter.page || 'form';
  
  if (page === 'admin') {
    return HtmlService.createHtmlOutput(getAdminLoginPage())
      .setTitle('Admin Login')
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
  }
  
  return HtmlService.createHtmlOutput(getFormPage())
    .setTitle('Property Agreement Form')
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

function doPost(e) {
  try {
    const data = JSON.parse(e.postData.contents);
    const action = data.action;
    
    switch(action) {
      case 'submitForm':
        return ContentService.createTextOutput(JSON.stringify(submitAgreement(data)))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'login':
        return ContentService.createTextOutput(JSON.stringify(adminLogin(data)))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'getAgreements':
        return ContentService.createTextOutput(JSON.stringify(getAllAgreements()))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'searchAgreements':
        return ContentService.createTextOutput(JSON.stringify(searchAgreements(data.query)))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'getStats':
        return ContentService.createTextOutput(JSON.stringify(getStatistics()))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'verifyPin':
        return ContentService.createTextOutput(JSON.stringify(verifyPin(data.pin)))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'holdForSignature':
        return ContentService.createTextOutput(JSON.stringify(holdForSignature(data)))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'getUnsignedAgreements':
        return ContentService.createTextOutput(JSON.stringify(getUnsignedAgreements()))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'updateWithSignatures':
        return ContentService.createTextOutput(JSON.stringify(updateWithSignatures(data)))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'getAgreementByRow':
        return ContentService.createTextOutput(JSON.stringify(getAgreementByRowNumber(data.rowNumber)))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'markDeviceProvisioned':
        return ContentService.createTextOutput(JSON.stringify(markDeviceProvisioned(data.rowNumber, data.provisioned)))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'getProvisionedDevices':
        return ContentService.createTextOutput(JSON.stringify(getProvisionedDevices()))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'markDueForReturn':
        return ContentService.createTextOutput(JSON.stringify(markDueForReturn(data.rowNumber, data.dueForReturn)))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'getDueForReturnDevices':
        return ContentService.createTextOutput(JSON.stringify(getDueForReturnDevices()))
          .setMimeType(ContentService.MimeType.JSON);
      
      // Retrieval Program endpoints
      case 'createRetrievalCase':
        return ContentService.createTextOutput(JSON.stringify(createRetrievalCase(data)))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'getRetrievalCases':
        return ContentService.createTextOutput(JSON.stringify(getRetrievalCases()))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'updateRetrievalStage':
        return ContentService.createTextOutput(JSON.stringify(updateRetrievalStage(data.caseId, data.newStage, data.notes)))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'updateRetrievalCallStatus':
        return ContentService.createTextOutput(JSON.stringify(updateRetrievalCallStatus(data.caseId, data.callStatus)))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'deleteRetrievalCase':
        return ContentService.createTextOutput(JSON.stringify(deleteRetrievalCase(data.caseId)))
          .setMimeType(ContentService.MimeType.JSON);
      
      case 'addRetrievalNote':
        return ContentService.createTextOutput(JSON.stringify(addRetrievalNote(data.caseId, data.note)))
          .setMimeType(ContentService.MimeType.JSON);
      
      default:
        throw new Error('Invalid action');
    }
  } catch(error) {
    return ContentService.createTextOutput(JSON.stringify({
      success: false,
      error: error.message
    })).setMimeType(ContentService.MimeType.JSON);
  }
}

// ============================================
// SPREADSHEET FUNCTIONS
// ============================================

function initializeSpreadsheet() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = ss.getSheetByName(CONFIG.SHEET_NAME);
  
  if (!sheet) {
    sheet = ss.insertSheet(CONFIG.SHEET_NAME);
    
    // Set up headers
    const headers = [
      'Timestamp',
      'Name',
      'Title',
      'Worker ID',
      'Has Different Training ID',
      'Training Worker ID',
      'Device',
      'Device Name',
      'Portable Charger',
      'Protective Cover',
      'Keyboard/Accessory',
      'Serial Number',
      'Esper Identifier Code',
      'Exchange Device',
      'Returning Device Name',
      'Returning Serial Number',
      'Agreement 1',
      'Agreement 2',
      'Agreement 3',
      'Employee Signature Date',
      'Employee Signature',
      'Supervisor Signature Date',
      'Supervisor Signature',
      'Send Copy to Employee',
      'Employee Email',
      'Provisioned',
      'DueForReturn'
    ];
    
    sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
    sheet.getRange(1, 1, 1, headers.length).setFontWeight('bold');
    sheet.setFrozenRows(1);
  }
  
  return sheet;
}

function submitAgreement(data) {
  try {
    const sheet = initializeSpreadsheet();
    
    const row = [
      new Date(),
      data.name || '',
      data.title || '',
      data.workerId || '',
      data.hasDifferentTrainingId || false,
      data.trainingWorkerId || data.workerId || '',
      data.device || false,
      data.deviceName || '',
      data.portableCharger || false,
      data.protectiveCover || false,
      data.keyboard || false,
      data.serialNumber || '',
      data.esperIdentifier || '',
      data.exchangeDevice || false,
      data.returningDeviceName || '',
      data.returningSerial || '',
      data.agreement1 || false,
      data.agreement2 || false,
      data.agreement3 || false,
      data.employeeSignatureDate || new Date(),
      data.employeeSignature || '',
      data.supervisorSignatureDate || new Date(),
      data.supervisorSignature || '',
      data.sendCopyToEmployee || false,
      data.employeeEmail || '',
      false, // Provisioned - default false
      false  // DueForReturn - default false
    ];
    
    sheet.appendRow(row);
    
    const rowNumber = sheet.getLastRow();
    
    // Send emails after successful submission
    try {
      sendNotificationEmails(data, rowNumber);
    } catch(emailError) {
      Logger.log('Email sending failed: ' + emailError.message);
      // Don't fail the submission if email fails
    }
    
    return {
      success: true,
      message: 'Agreement submitted successfully',
      rowNumber: rowNumber
    };
  } catch(error) {
    return {
      success: false,
      error: error.message
    };
  }
}

function getAllAgreements() {
  try {
    const sheet = initializeSpreadsheet();
    const data = sheet.getDataRange().getValues();
    
    if (data.length <= 1) {
      return { success: true, agreements: [] };
    }
    
    const headers = data[0];
    const agreements = [];
    
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const agreement = {};
      
      headers.forEach((header, index) => {
        agreement[header] = row[index];
      });
      
      agreement.rowNumber = i + 1;
      agreements.push(agreement);
    }
    
    return {
      success: true,
      agreements: agreements.reverse() // Most recent first
    };
  } catch(error) {
    return {
      success: false,
      error: error.message
    };
  }
}

function searchAgreements(query) {
  try {
    const allData = getAllAgreements();
    
    if (!allData.success) {
      return allData;
    }
    
    const searchTerm = query.toLowerCase();
    const filtered = allData.agreements.filter(agreement => {
      return (
        (agreement.Name && agreement.Name.toString().toLowerCase().includes(searchTerm)) ||
        (agreement['Worker ID'] && agreement['Worker ID'].toString().toLowerCase().includes(searchTerm)) ||
        (agreement['Serial Number'] && agreement['Serial Number'].toString().toLowerCase().includes(searchTerm)) ||
        (agreement['Esper Identifier Code'] && agreement['Esper Identifier Code'].toString().toLowerCase().includes(searchTerm))
      );
    });
    
    return {
      success: true,
      agreements: filtered
    };
  } catch(error) {
    return {
      success: false,
      error: error.message
    };
  }
}

function getStatistics() {
  try {
    const allData = getAllAgreements();
    
    if (!allData.success) {
      return allData;
    }
    
    const agreements = allData.agreements;
    
    // Count Esper IDs (non-empty)
    const esperIds = agreements.filter(a => 
      a['Esper Identifier Code'] && a['Esper Identifier Code'].toString().trim() !== ''
    ).length;
    
    return {
      success: true,
      stats: {
        totalAgreements: agreements.length,
        esperIds: esperIds,
        lastSubmission: agreements.length > 0 ? agreements[0].Timestamp : null
      }
    };
  } catch(error) {
    return {
      success: false,
      error: error.message
    };
  }
}

// ============================================
// AUTHENTICATION
// ============================================

function adminLogin(data) {
  const username = data.username;
  const password = data.password;
  
  if (username === CONFIG.ADMIN_USERNAME && password === CONFIG.ADMIN_PASSWORD) {
    return {
      success: true,
      message: 'Login successful'
    };
  }
  
  return {
    success: false,
    error: 'Invalid credentials'
  };
}

function verifyPin(pin) {
  if (pin === CONFIG.APF_PIN) {
    return {
      success: true,
      message: 'PIN verified'
    };
  }
  
  return {
    success: false,
    error: 'Invalid PIN'
  };
}

// ============================================
// HOLD FOR SIGNATURE FUNCTIONS
// ============================================

function holdForSignature(data) {
  try {
    const sheet = initializeSpreadsheet();
    
    // Create row without signatures
    const row = [
      new Date(),
      data.name || '',
      data.title || '',
      data.workerId || '',
      data.hasDifferentTrainingId || false,
      data.trainingWorkerId || data.workerId || '',
      data.device || false,
      data.deviceName || '',
      data.portableCharger || false,
      data.protectiveCover || false,
      data.keyboard || false,
      data.serialNumber || '',
      data.esperIdentifier || '',
      data.exchangeDevice || false,
      data.returningDeviceName || '',
      data.returningSerial || '',
      data.agreement1 || false,
      data.agreement2 || false,
      data.agreement3 || false,
      '', // Employee Signature Date - empty
      '', // Employee Signature - empty
      '', // Supervisor Signature Date - empty
      '', // Supervisor Signature - empty
      false, // Send Copy to Employee
      '', // Employee Email
      false, // Provisioned - default false
      false  // DueForReturn - default false
    ];
    
    sheet.appendRow(row);
    const rowNumber = sheet.getLastRow();
    
    return {
      success: true,
      message: 'Form held for signature',
      rowNumber: rowNumber
    };
  } catch(error) {
    return {
      success: false,
      error: error.message
    };
  }
}

function getUnsignedAgreements() {
  try {
    const sheet = initializeSpreadsheet();
    const data = sheet.getDataRange().getValues();
    
    if (data.length <= 1) {
      return { success: true, agreements: [] };
    }
    
    const headers = data[0];
    const unsigned = [];
    
    // Find column indices
    const empSigIndex = headers.indexOf('Employee Signature');
    const supSigIndex = headers.indexOf('Supervisor Signature');
    
    // If signature columns don't exist, return empty (sheet may not be set up yet)
    if (empSigIndex === -1 || supSigIndex === -1) {
      Logger.log('Signature columns not found. Headers: ' + headers.join(', '));
      return { success: true, agreements: [] };
    }
    
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      
      // Check if both signatures are empty
      const empSig = row[empSigIndex];
      const supSig = row[supSigIndex];
      
      if ((!empSig || empSig.toString().trim() === '') && 
          (!supSig || supSig.toString().trim() === '')) {
        const agreement = {};
        headers.forEach((header, index) => {
          agreement[header] = row[index];
        });
        agreement.rowNumber = i + 1;
        unsigned.push(agreement);
      }
    }
    
    return {
      success: true,
      agreements: unsigned.reverse() // Most recent first
    };
  } catch(error) {
    Logger.log('getUnsignedAgreements error: ' + error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

function getAgreementByRowNumber(rowNumber) {
  try {
    if (!rowNumber) {
      return { success: false, error: 'Row number is required' };
    }
    
    const sheet = initializeSpreadsheet();
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    // Row number is 1-indexed (row 1 is headers, row 2 is first data row)
    const rowIndex = parseInt(rowNumber) - 1;
    
    if (rowIndex < 1 || rowIndex >= data.length) {
      return { success: false, error: 'Agreement not found' };
    }
    
    const row = data[rowIndex];
    const agreement = {};
    
    headers.forEach((header, index) => {
      agreement[header] = row[index];
    });
    agreement.rowNumber = parseInt(rowNumber);
    
    return {
      success: true,
      agreement: agreement
    };
  } catch(error) {
    Logger.log('getAgreementByRowNumber error: ' + error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

function updateWithSignatures(data) {
  try {
    const sheet = initializeSpreadsheet();
    const allData = sheet.getDataRange().getValues();
    const headers = allData[0];
    
    // Find column indices (0-indexed from headers array)
    const nameIndex = headers.indexOf('Name');
    const workerIdIndex = headers.indexOf('Worker ID');
    const empSigIndex = headers.indexOf('Employee Signature');
    const supSigIndex = headers.indexOf('Supervisor Signature');
    const empSigDateIndex = headers.indexOf('Employee Signature Date');
    const supSigDateIndex = headers.indexOf('Supervisor Signature Date');
    const sendCopyIndex = headers.indexOf('Send Copy to Employee');
    const emailIndex = headers.indexOf('Employee Email');
    
    // Additional columns that may need updating (filled by IT after HR creates request)
    const deviceNameIndex = headers.indexOf('Device Name');
    const serialNumberIndex = headers.indexOf('Serial Number');
    const esperIdentifierIndex = headers.indexOf('Esper Identifier Code');
    const trainingWorkerIdIndex = headers.indexOf('Training Worker ID');
    
    // Validate that required columns exist
    const requiredColumns = {
      'Name': nameIndex,
      'Worker ID': workerIdIndex,
      'Employee Signature': empSigIndex,
      'Supervisor Signature': supSigIndex,
      'Employee Signature Date': empSigDateIndex,
      'Supervisor Signature Date': supSigDateIndex
    };
    
    for (const [colName, colIndex] of Object.entries(requiredColumns)) {
      if (colIndex === -1) {
        Logger.log('Missing column: ' + colName + '. Headers found: ' + headers.join(', '));
        return {
          success: false,
          error: 'Spreadsheet missing required column: ' + colName
        };
      }
    }
    
    // Find the matching unsigned row
    let matchingRow = -1;
    
    // PRIORITY 1: If rowNumber is provided (from barcode scan), use it directly
    if (data.rowNumber) {
      const rowIndex = parseInt(data.rowNumber);
      if (rowIndex >= 2 && rowIndex <= allData.length) {
        const row = allData[rowIndex - 1];
        const empSig = row[empSigIndex];
        const supSig = row[supSigIndex];
        
        // Verify the row is unsigned
        if ((!empSig || empSig.toString().trim() === '') && 
            (!supSig || supSig.toString().trim() === '')) {
          matchingRow = rowIndex;
          Logger.log('Matched by rowNumber: ' + matchingRow);
        } else {
          Logger.log('Row ' + rowIndex + ' is already signed');
        }
      }
    }
    
    // PRIORITY 2: Fall back to name + workerId matching (for non-barcode submissions)
    if (matchingRow === -1) {
      for (let i = 1; i < allData.length; i++) {
        const row = allData[i];
        const empSig = row[empSigIndex];
        const supSig = row[supSigIndex];
        
        // Check if row is unsigned
        if ((!empSig || empSig.toString().trim() === '') && 
            (!supSig || supSig.toString().trim() === '')) {
          // Check if name and workerId match
          if (row[nameIndex] === data.name && 
              row[workerIdIndex].toString() === data.workerId.toString()) {
            matchingRow = i + 1; // Sheet rows are 1-indexed
            Logger.log('Matched by name + workerId: ' + matchingRow);
            break;
          }
        }
      }
    }
    
    if (matchingRow === -1) {
      return {
        success: false,
        error: 'No matching unsigned agreement found'
      };
    }
    
    // Update the row with signatures (column indices are 0-based, getRange needs 1-based)
    sheet.getRange(matchingRow, empSigDateIndex + 1).setValue(data.employeeSignatureDate || new Date());
    sheet.getRange(matchingRow, empSigIndex + 1).setValue(data.employeeSignature || '');
    sheet.getRange(matchingRow, supSigDateIndex + 1).setValue(data.supervisorSignatureDate || new Date());
    sheet.getRange(matchingRow, supSigIndex + 1).setValue(data.supervisorSignature || '');
    
    // Update Worker ID if provided (IT fills this in after HR creates request)
    if (data.workerId && workerIdIndex !== -1) {
      sheet.getRange(matchingRow, workerIdIndex + 1).setValue(data.workerId);
    }
    
    // Update Training Worker ID if provided
    if (data.trainingWorkerId && trainingWorkerIdIndex !== -1) {
      sheet.getRange(matchingRow, trainingWorkerIdIndex + 1).setValue(data.trainingWorkerId);
    }
    
    // Update device info if provided (IT fills these in)
    if (data.deviceName && deviceNameIndex !== -1) {
      sheet.getRange(matchingRow, deviceNameIndex + 1).setValue(data.deviceName);
    }
    if (data.serialNumber && serialNumberIndex !== -1) {
      sheet.getRange(matchingRow, serialNumberIndex + 1).setValue(data.serialNumber);
    }
    if (data.esperIdentifier && esperIdentifierIndex !== -1) {
      sheet.getRange(matchingRow, esperIdentifierIndex + 1).setValue(data.esperIdentifier);
    }
    
    // Only update email columns if they exist (they might be missing in older sheets)
    if (sendCopyIndex !== -1) {
      sheet.getRange(matchingRow, sendCopyIndex + 1).setValue(data.sendCopyToEmployee || false);
    }
    if (emailIndex !== -1) {
      sheet.getRange(matchingRow, emailIndex + 1).setValue(data.employeeEmail || '');
    }
    
    // Clear the Provisioned flag once signed (device is picked up)
    const provisionedIndex = headers.indexOf('Provisioned');
    if (provisionedIndex !== -1) {
      sheet.getRange(matchingRow, provisionedIndex + 1).setValue(false);
    }
    
    // Send emails after successful update
    try {
      sendNotificationEmails(data, matchingRow);
    } catch(emailError) {
      Logger.log('Email sending failed: ' + emailError.message);
    }
    
    return {
      success: true,
      message: 'Agreement updated with signatures',
      rowNumber: matchingRow
    };
  } catch(error) {
    Logger.log('updateWithSignatures error: ' + error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

// ============================================
// DEVICE PROVISIONING FUNCTIONS
// ============================================

/**
 * Mark a device as provisioned (ready for pickup)
 * This notifies HR that the device is ready
 */
function markDeviceProvisioned(rowNumber, provisioned) {
  try {
    if (!rowNumber) {
      return { success: false, error: 'Row number is required' };
    }
    
    const sheet = initializeSpreadsheet();
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    
    // Find or create Provisioned column
    let provisionedIndex = headers.indexOf('Provisioned');
    
    if (provisionedIndex === -1) {
      // Add the Provisioned column if it doesn't exist
      provisionedIndex = headers.length;
      sheet.getRange(1, provisionedIndex + 1).setValue('Provisioned');
    }
    
    // Validate row exists
    const rowIndex = parseInt(rowNumber);
    if (rowIndex < 2 || rowIndex > sheet.getLastRow()) {
      return { success: false, error: 'Invalid row number' };
    }
    
    // Get the agreement data for notification
    const rowData = sheet.getRange(rowIndex, 1, 1, headers.length).getValues()[0];
    const agreement = {};
    headers.forEach((header, index) => {
      agreement[header] = rowData[index];
    });
    agreement.rowNumber = rowIndex;
    
    // Update the Provisioned status
    const newStatus = provisioned !== false; // Default to true if not explicitly false
    sheet.getRange(rowIndex, provisionedIndex + 1).setValue(newStatus);
    
    // Send notification to HR if marking as provisioned
    if (newStatus) {
      try {
        sendProvisionedNotification(agreement);
      } catch(emailError) {
        Logger.log('HR notification failed: ' + emailError.message);
        // Don't fail the operation if email fails
      }
    }
    
    return {
      success: true,
      message: newStatus ? 'Device marked as provisioned' : 'Device unmarked as provisioned',
      rowNumber: rowIndex,
      provisioned: newStatus
    };
  } catch(error) {
    Logger.log('markDeviceProvisioned error: ' + error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Get all provisioned devices that are still unsigned (ready for pickup)
 */
function getProvisionedDevices() {
  try {
    const sheet = initializeSpreadsheet();
    const data = sheet.getDataRange().getValues();
    
    if (data.length <= 1) {
      return { success: true, devices: [] };
    }
    
    const headers = data[0];
    const devices = [];
    
    // Find column indices
    const empSigIndex = headers.indexOf('Employee Signature');
    const supSigIndex = headers.indexOf('Supervisor Signature');
    const provisionedIndex = headers.indexOf('Provisioned');
    
    // If required columns don't exist, return empty
    if (empSigIndex === -1 || supSigIndex === -1) {
      Logger.log('Required columns not found');
      return { success: true, devices: [] };
    }
    
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      
      // Check if provisioned
      const isProvisioned = provisionedIndex !== -1 && 
        (row[provisionedIndex] === true || row[provisionedIndex] === 'TRUE');
      
      if (!isProvisioned) continue;
      
      // Check if still unsigned (no signatures)
      const empSig = row[empSigIndex];
      const supSig = row[supSigIndex];
      const isUnsigned = (!empSig || empSig.toString().trim() === '') && 
                         (!supSig || supSig.toString().trim() === '');
      
      // Only include if provisioned AND still unsigned
      if (isUnsigned) {
        const device = {};
        headers.forEach((header, index) => {
          device[header] = row[index];
        });
        device.rowNumber = i + 1;
        devices.push(device);
      }
    }
    
    return {
      success: true,
      devices: devices.reverse() // Most recent first
    };
  } catch(error) {
    Logger.log('getProvisionedDevices error: ' + error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

// ============================================
// DUE FOR RETURN FUNCTIONS
// ============================================

/**
 * Mark a device as due for return (for coordinator retrieval)
 */
function markDueForReturn(rowNumber, dueForReturn) {
  try {
    if (!rowNumber) {
      return { success: false, error: 'Row number is required' };
    }
    
    const sheet = initializeSpreadsheet();
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    
    // Find or create DueForReturn column
    let dueForReturnIndex = headers.indexOf('DueForReturn');
    
    if (dueForReturnIndex === -1) {
      // Add the DueForReturn column if it doesn't exist
      dueForReturnIndex = headers.length;
      sheet.getRange(1, dueForReturnIndex + 1).setValue('DueForReturn');
    }
    
    // Validate row exists
    const rowIndex = parseInt(rowNumber);
    if (rowIndex < 2 || rowIndex > sheet.getLastRow()) {
      return { success: false, error: 'Invalid row number' };
    }
    
    // Update the DueForReturn status
    const newStatus = dueForReturn !== false; // Default to true if not explicitly false
    sheet.getRange(rowIndex, dueForReturnIndex + 1).setValue(newStatus);
    
    return {
      success: true,
      message: newStatus ? 'Device marked as due for return' : 'Device unmarked as due for return',
      rowNumber: rowIndex,
      dueForReturn: newStatus
    };
  } catch(error) {
    Logger.log('markDueForReturn error: ' + error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Get all devices marked as due for return
 */
function getDueForReturnDevices() {
  try {
    const sheet = initializeSpreadsheet();
    const data = sheet.getDataRange().getValues();
    
    if (data.length <= 1) {
      return { success: true, devices: [] };
    }
    
    const headers = data[0];
    const devices = [];
    
    // Find column index
    const dueForReturnIndex = headers.indexOf('DueForReturn');
    
    // If column doesn't exist, return empty
    if (dueForReturnIndex === -1) {
      Logger.log('DueForReturn column not found');
      return { success: true, devices: [] };
    }
    
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      
      // Check if marked as due for return
      const isDueForReturn = row[dueForReturnIndex] === true || row[dueForReturnIndex] === 'TRUE';
      
      if (isDueForReturn) {
        const device = {};
        headers.forEach((header, index) => {
          device[header] = row[index];
        });
        device.rowNumber = i + 1;
        devices.push(device);
      }
    }
    
    return {
      success: true,
      devices: devices.reverse() // Most recent first
    };
  } catch(error) {
    Logger.log('getDueForReturnDevices error: ' + error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

// ============================================
// RETRIEVAL PROGRAM FUNCTIONS
// ============================================

/**
 * Initialize the Retrievals sheet
 * Ensures headers exist even if sheet was created manually
 */
function initializeRetrievalSheet() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = ss.getSheetByName(CONFIG.RETRIEVAL_SHEET_NAME);
  
  const expectedHeaders = [
    'CaseID',           // Unique identifier
    'Created',          // Timestamp when case was created
    'Stage',            // Current stage (1-8)
    'StaffName',        // Employee name
    'WorkerID',         // Employee worker ID
    'Title',            // Job title (RN, LPN, etc.)
    'DeviceType',       // Type of device (Lenovo Tab, etc.)
    'DeviceName',       // Esper device name
    'SerialNumber',     // Device serial number
    'EsperID',          // Esper identifier code
    'LastUpdated',      // When stage was last changed
    'CallStatus',       // For Stage 3: 'successful' or 'did_not_answer'
    'Notes',            // JSON array of notes with timestamps
    'AssignedTo',       // Coordinator handling this case
    'ResolvedDate',     // Date when moved to stage 7 or 8
    'IsDeleted'         // Soft delete flag
  ];
  
  if (!sheet) {
    // Create new sheet with headers
    sheet = ss.insertSheet(CONFIG.RETRIEVAL_SHEET_NAME);
    sheet.getRange(1, 1, 1, expectedHeaders.length).setValues([expectedHeaders]);
    sheet.getRange(1, 1, 1, expectedHeaders.length).setFontWeight('bold');
    sheet.setFrozenRows(1);
  } else {
    // Sheet exists - check if headers are correct
    const firstRow = sheet.getRange(1, 1, 1, expectedHeaders.length).getValues()[0];
    const firstCellValue = firstRow[0] ? firstRow[0].toString() : '';
    
    // If first cell doesn't match expected header, headers are missing
    // Check if it looks like a CaseID (starts with "RET-") instead of "CaseID"
    if (firstCellValue !== 'CaseID' && (firstCellValue.startsWith('RET-') || firstCellValue === '')) {
      // Headers are missing - insert a row at the top and add headers
      sheet.insertRowBefore(1);
      sheet.getRange(1, 1, 1, expectedHeaders.length).setValues([expectedHeaders]);
      sheet.getRange(1, 1, 1, expectedHeaders.length).setFontWeight('bold');
      sheet.setFrozenRows(1);
      Logger.log('Headers were missing - added header row to Retrievals sheet');
    }
  }
  
  return sheet;
}

/**
 * Generate a unique case ID
 */
function generateCaseID() {
  const timestamp = new Date().getTime();
  const random = Math.floor(Math.random() * 1000);
  return `RET-${timestamp}-${random}`;
}

/**
 * Create a new retrieval case (copies device info from Esper into sheet)
 */
function createRetrievalCase(data) {
  try {
    const sheet = initializeRetrievalSheet();
    
    const caseId = generateCaseID();
    const now = new Date();
    
    // Initial notes array with creation entry
    const initialNotes = JSON.stringify([{
      timestamp: now.toISOString(),
      text: 'Case created - Device added to retrieval program',
      type: 'system'
    }]);
    
    const row = [
      caseId,                           // CaseID
      now,                              // Created
      1,                                // Stage (starts at 1)
      data.staffName || '',             // StaffName
      data.workerId || '',              // WorkerID
      data.title || '',                 // Title
      data.deviceType || '',            // DeviceType
      data.deviceName || '',            // DeviceName
      data.serialNumber || '',          // SerialNumber
      data.esperID || '',               // EsperID
      now,                              // LastUpdated
      '',                               // CallStatus (empty until Stage 3)
      initialNotes,                     // Notes
      data.assignedTo || '',            // AssignedTo
      '',                               // ResolvedDate
      false                             // IsDeleted
    ];
    
    sheet.appendRow(row);
    
    return {
      success: true,
      message: 'Retrieval case created successfully',
      caseId: caseId,
      rowNumber: sheet.getLastRow()
    };
  } catch(error) {
    Logger.log('createRetrievalCase error: ' + error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Get all retrieval cases (excluding soft-deleted)
 */
function getRetrievalCases() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let sheet = ss.getSheetByName(CONFIG.RETRIEVAL_SHEET_NAME);
    
    // Debug: Check if sheet exists
    if (!sheet) {
      return { 
        success: true, 
        cases: [], 
        debug: { 
          message: 'Sheet not found, will be created',
          sheetName: CONFIG.RETRIEVAL_SHEET_NAME,
          availableSheets: ss.getSheets().map(s => s.getName())
        }
      };
    }
    
    const data = sheet.getDataRange().getValues();
    
    // Debug info
    const debugInfo = {
      sheetName: sheet.getName(),
      totalRows: data.length,
      headers: data.length > 0 ? data[0] : [],
      lastRow: sheet.getLastRow(),
      lastColumn: sheet.getLastColumn()
    };
    
    if (data.length <= 1) {
      return { 
        success: true, 
        cases: [],
        debug: { ...debugInfo, message: 'Only header row found' }
      };
    }
    
    const headers = data[0];
    const cases = [];
    
    // Find column indices
    const isDeletedIndex = headers.indexOf('IsDeleted');
    
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      
      // Skip empty rows (check if CaseID is empty)
      if (!row[0] || row[0].toString().trim() === '') {
        continue;
      }
      
      // Skip deleted cases
      if (isDeletedIndex !== -1 && (row[isDeletedIndex] === true || row[isDeletedIndex] === 'TRUE')) {
        continue;
      }
      
      const caseObj = {};
      headers.forEach((header, index) => {
        // Parse Notes JSON if present
        if (header === 'Notes' && row[index]) {
          try {
            caseObj[header] = JSON.parse(row[index]);
          } catch(e) {
            caseObj[header] = [];
          }
        } else {
          caseObj[header] = row[index];
        }
      });
      
      caseObj.rowNumber = i + 1;
      cases.push(caseObj);
    }
    
    return {
      success: true,
      cases: cases,
      stages: CONFIG.RETRIEVAL_STAGES,
      debug: { ...debugInfo, casesFound: cases.length }
    };
  } catch(error) {
    Logger.log('getRetrievalCases error: ' + error.message);
    return {
      success: false,
      error: error.message,
      debug: { errorStack: error.stack }
    };
  }
}

/**
 * Update the stage of a retrieval case
 */
function updateRetrievalStage(caseId, newStage, notes) {
  try {
    const sheet = initializeRetrievalSheet();
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    // Find column indices
    const caseIdIndex = headers.indexOf('CaseID');
    const stageIndex = headers.indexOf('Stage');
    const lastUpdatedIndex = headers.indexOf('LastUpdated');
    const notesIndex = headers.indexOf('Notes');
    const resolvedDateIndex = headers.indexOf('ResolvedDate');
    const isDeletedIndex = headers.indexOf('IsDeleted');
    
    // Find the row with matching CaseID
    let targetRow = -1;
    for (let i = 1; i < data.length; i++) {
      if (data[i][caseIdIndex] === caseId) {
        // Check if deleted
        if (isDeletedIndex !== -1 && (data[i][isDeletedIndex] === true || data[i][isDeletedIndex] === 'TRUE')) {
          return { success: false, error: 'Case has been deleted' };
        }
        targetRow = i + 1; // Sheet rows are 1-indexed
        break;
      }
    }
    
    if (targetRow === -1) {
      return { success: false, error: 'Case not found' };
    }
    
    const now = new Date();
    const stageNum = parseInt(newStage);
    
    // Update stage
    sheet.getRange(targetRow, stageIndex + 1).setValue(stageNum);
    
    // Update last updated timestamp
    sheet.getRange(targetRow, lastUpdatedIndex + 1).setValue(now);
    
    // Add note about stage change
    let existingNotes = [];
    try {
      existingNotes = JSON.parse(data[targetRow - 1][notesIndex] || '[]');
    } catch(e) {
      existingNotes = [];
    }
    
    const stageName = CONFIG.RETRIEVAL_STAGES[stageNum] || `Stage ${stageNum}`;
    existingNotes.push({
      timestamp: now.toISOString(),
      text: `Stage changed to: ${stageName}${notes ? ' - ' + notes : ''}`,
      type: 'stage_change'
    });
    
    sheet.getRange(targetRow, notesIndex + 1).setValue(JSON.stringify(existingNotes));
    
    // If moving to stage 7 or 8, set resolved date
    if (stageNum === 7 || stageNum === 8) {
      sheet.getRange(targetRow, resolvedDateIndex + 1).setValue(now);
    }
    
    return {
      success: true,
      message: `Case updated to ${stageName}`,
      caseId: caseId,
      newStage: stageNum
    };
  } catch(error) {
    Logger.log('updateRetrievalStage error: ' + error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Update call status for Stage 3
 */
function updateRetrievalCallStatus(caseId, callStatus) {
  try {
    const sheet = initializeRetrievalSheet();
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    const caseIdIndex = headers.indexOf('CaseID');
    const callStatusIndex = headers.indexOf('CallStatus');
    const notesIndex = headers.indexOf('Notes');
    const lastUpdatedIndex = headers.indexOf('LastUpdated');
    
    // Find the row
    let targetRow = -1;
    for (let i = 1; i < data.length; i++) {
      if (data[i][caseIdIndex] === caseId) {
        targetRow = i + 1;
        break;
      }
    }
    
    if (targetRow === -1) {
      return { success: false, error: 'Case not found' };
    }
    
    const now = new Date();
    
    // Update call status
    sheet.getRange(targetRow, callStatusIndex + 1).setValue(callStatus);
    sheet.getRange(targetRow, lastUpdatedIndex + 1).setValue(now);
    
    // Add note
    let existingNotes = [];
    try {
      existingNotes = JSON.parse(data[targetRow - 1][notesIndex] || '[]');
    } catch(e) {
      existingNotes = [];
    }
    
    const statusText = callStatus === 'successful' ? 'Call successful' : 'Call - Did not answer';
    existingNotes.push({
      timestamp: now.toISOString(),
      text: statusText,
      type: 'call_status'
    });
    
    sheet.getRange(targetRow, notesIndex + 1).setValue(JSON.stringify(existingNotes));
    
    return {
      success: true,
      message: 'Call status updated',
      callStatus: callStatus
    };
  } catch(error) {
    Logger.log('updateRetrievalCallStatus error: ' + error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Soft delete a retrieval case
 */
function deleteRetrievalCase(caseId) {
  try {
    const sheet = initializeRetrievalSheet();
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    const caseIdIndex = headers.indexOf('CaseID');
    const isDeletedIndex = headers.indexOf('IsDeleted');
    const notesIndex = headers.indexOf('Notes');
    const lastUpdatedIndex = headers.indexOf('LastUpdated');
    
    // Find the row
    let targetRow = -1;
    for (let i = 1; i < data.length; i++) {
      if (data[i][caseIdIndex] === caseId) {
        targetRow = i + 1;
        break;
      }
    }
    
    if (targetRow === -1) {
      return { success: false, error: 'Case not found' };
    }
    
    const now = new Date();
    
    // Soft delete
    sheet.getRange(targetRow, isDeletedIndex + 1).setValue(true);
    sheet.getRange(targetRow, lastUpdatedIndex + 1).setValue(now);
    
    // Add deletion note
    let existingNotes = [];
    try {
      existingNotes = JSON.parse(data[targetRow - 1][notesIndex] || '[]');
    } catch(e) {
      existingNotes = [];
    }
    
    existingNotes.push({
      timestamp: now.toISOString(),
      text: 'Case removed from retrieval program',
      type: 'deleted'
    });
    
    sheet.getRange(targetRow, notesIndex + 1).setValue(JSON.stringify(existingNotes));
    
    return {
      success: true,
      message: 'Case removed successfully',
      caseId: caseId
    };
  } catch(error) {
    Logger.log('deleteRetrievalCase error: ' + error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Add a note to a retrieval case
 */
function addRetrievalNote(caseId, noteText) {
  try {
    const sheet = initializeRetrievalSheet();
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    const caseIdIndex = headers.indexOf('CaseID');
    const notesIndex = headers.indexOf('Notes');
    const lastUpdatedIndex = headers.indexOf('LastUpdated');
    
    // Find the row
    let targetRow = -1;
    for (let i = 1; i < data.length; i++) {
      if (data[i][caseIdIndex] === caseId) {
        targetRow = i + 1;
        break;
      }
    }
    
    if (targetRow === -1) {
      return { success: false, error: 'Case not found' };
    }
    
    const now = new Date();
    
    // Add note
    let existingNotes = [];
    try {
      existingNotes = JSON.parse(data[targetRow - 1][notesIndex] || '[]');
    } catch(e) {
      existingNotes = [];
    }
    
    existingNotes.push({
      timestamp: now.toISOString(),
      text: noteText,
      type: 'manual'
    });
    
    sheet.getRange(targetRow, notesIndex + 1).setValue(JSON.stringify(existingNotes));
    sheet.getRange(targetRow, lastUpdatedIndex + 1).setValue(now);
    
    return {
      success: true,
      message: 'Note added successfully',
      notes: existingNotes
    };
  } catch(error) {
    Logger.log('addRetrievalNote error: ' + error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

// ============================================
// EMAIL NOTIFICATION FUNCTIONS
// ============================================

/**
 * Send notification to HR when a device is marked as provisioned
 */
function sendProvisionedNotification(agreement) {
  // Skip if no HR emails configured
  if (!CONFIG.HR_EMAILS || CONFIG.HR_EMAILS.length === 0) {
    Logger.log('No HR emails configured for provisioning notifications');
    return;
  }
  
  const subject = `Device Ready for Pickup - ${agreement.Name || 'Unknown'}`;
  
  const body = `
A device has been provisioned and is ready for pickup.

EMPLOYEE INFORMATION:
Name: ${agreement.Name || 'N/A'}
Title: ${agreement.Title || 'N/A'}
Worker ID: ${agreement['Worker ID'] || 'N/A'}

DEVICE DETAILS:
Device: ${agreement['Device Name'] || 'N/A'}
Serial Number: ${agreement['Serial Number'] || 'N/A'}
Esper ID: ${agreement['Esper Identifier Code'] || 'N/A'}

This device is ready for the employee to pick up and sign the property agreement.

---
${CONFIG.COMPANY_INFO.name}
${CONFIG.COMPANY_INFO.address}
${CONFIG.COMPANY_INFO.city}
${CONFIG.COMPANY_INFO.phone}
  `.trim();
  
  CONFIG.HR_EMAILS.forEach(email => {
    try {
      MailApp.sendEmail({
        to: email,
        subject: subject,
        body: body
      });
      Logger.log('HR notification sent to: ' + email);
    } catch(e) {
      Logger.log('Failed to send HR notification to ' + email + ': ' + e.message);
    }
  });
}

// ============================================
// EMAIL FUNCTIONS
// ============================================

function sendNotificationEmails(agreementData, rowNumber) {
  Logger.log('Starting email send process for: ' + agreementData.name);
  
  const pdfResult = generatePDFBlob(agreementData);
  
  if (!pdfResult.success) {
    Logger.log('PDF generation failed: ' + pdfResult.error);
    throw new Error('Failed to generate PDF: ' + pdfResult.error);
  }
  
  Logger.log('PDF generated successfully');
  
  const pdfBytes = pdfResult.blob.getBytes();
  const filename = pdfResult.filename;
  
  // Send to admin emails
  if (CONFIG.ADMIN_EMAILS && CONFIG.ADMIN_EMAILS.length > 0) {
    const adminSubject = `New Property Agreement Submitted - ${agreementData.name}`;
    const adminBody = generateAdminEmailBody(agreementData);
    
    Logger.log('Sending to ' + CONFIG.ADMIN_EMAILS.length + ' admin email(s)');
    
    CONFIG.ADMIN_EMAILS.forEach(email => {
      try {
        // Create a fresh blob for each email
        const attachment = Utilities.newBlob(pdfBytes, 'application/pdf', filename);
        
        MailApp.sendEmail({
          to: email,
          subject: adminSubject,
          body: adminBody,
          attachments: [attachment]
        });
        Logger.log('Successfully sent to admin: ' + email);
      } catch(e) {
        Logger.log('Failed to send to admin email ' + email + ': ' + e.message);
      }
    });
  } else {
    Logger.log('No admin emails configured');
  }
  
  // Send to employee if requested
  if (agreementData.sendCopyToEmployee && agreementData.employeeEmail) {
    const employeeSubject = 'Your Property Agreement - WELLBOUND';
    const employeeBody = generateEmployeeEmailBody(agreementData);
    
    try {
      // Create a fresh blob for employee email
      const attachment = Utilities.newBlob(pdfBytes, 'application/pdf', filename);
      
      MailApp.sendEmail({
        to: agreementData.employeeEmail,
        subject: employeeSubject,
        body: employeeBody,
        attachments: [attachment]
      });
      Logger.log('Successfully sent to employee: ' + agreementData.employeeEmail);
    } catch(e) {
      Logger.log('Failed to send to employee email: ' + e.message);
    }
  }
  
  Logger.log('Email send process completed');
}

function generateAdminEmailBody(data) {
  const devicesList = [];
  if (data.device) devicesList.push(data.deviceName || 'Device');
  if (data.portableCharger) devicesList.push('Portable Charger');
  if (data.protectiveCover) devicesList.push('Protective Cover');
  if (data.keyboard) devicesList.push('Keyboard/Accessory');
  
  return `
A new Property Agreement has been submitted.

EMPLOYEE INFORMATION:
Name: ${data.name || 'N/A'}
Title: ${data.title || 'N/A'}
Worker ID: ${data.workerId || 'N/A'}
${data.hasDifferentTrainingId ? 'Training Worker ID: ' + (data.trainingWorkerId || 'N/A') + '\n' : ''}

PROPERTY DETAILS:
Devices Received: ${devicesList.join(', ') || 'None'}
Serial Number: ${data.serialNumber || 'N/A'}
Esper Identifier Code: ${data.esperIdentifier || 'N/A'}

${data.exchangeDevice ? 'EXCHANGE INFORMATION:\nReturning Device: ' + (data.returningDeviceName || 'N/A') + '\nReturning Serial: ' + (data.returningSerial || 'N/A') + '\n' : ''}

Submission Date: ${new Date().toLocaleString()}

Please see the attached PDF for the complete signed agreement.

---
${CONFIG.COMPANY_INFO.name}
${CONFIG.COMPANY_INFO.address}
${CONFIG.COMPANY_INFO.city}
${CONFIG.COMPANY_INFO.phone}
  `.trim();
}

function generateEmployeeEmailBody(data) {
  return `
Dear ${data.name},

Thank you for completing your Property Agreement form with WELLBOUND.

Please find attached a copy of your signed Property Agreement for your records. This document confirms the property you have received and your acknowledgment of the terms and conditions.

If you have any questions or concerns, please contact your supervisor or the Human Resources department.

Best regards,
${CONFIG.COMPANY_INFO.name}
${CONFIG.COMPANY_INFO.address}
${CONFIG.COMPANY_INFO.city}
${CONFIG.COMPANY_INFO.phone}
  `.trim();
}

// ============================================
// PDF GENERATION
// ============================================

function generatePDF(rowNumber) {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(CONFIG.SHEET_NAME);
    const data = sheet.getRange(rowNumber, 1, 1, sheet.getLastColumn()).getValues()[0];
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    
    const agreement = {};
    headers.forEach((header, index) => {
      agreement[header] = data[index];
    });
    
    // Create HTML for PDF
    const html = generatePDFHTML(agreement);
    
    // Convert to PDF
    const blob = Utilities.newBlob(html, 'text/html', 'agreement.html').getAs('application/pdf');
    
    return {
      success: true,
      pdf: Utilities.base64Encode(blob.getBytes()),
      filename: `Agreement_${agreement.Name}_${agreement['Worker ID']}.pdf`
    };
  } catch(error) {
    return {
      success: false,
      error: error.message
    };
  }
}

function generatePDFBlob(agreementData) {
  try {
    // Create HTML for PDF
    const html = generatePDFHTML(agreementData);
    
    // Convert to PDF
    const blob = Utilities.newBlob(html, 'text/html', 'agreement.html').getAs('application/pdf');
    
    const filename = `Agreement_${agreementData.name}_${agreementData.workerId}.pdf`;
    
    return {
      success: true,
      blob: blob,
      filename: filename
    };
  } catch(error) {
    return {
      success: false,
      error: error.message
    };
  }
}

function generatePDFHTML(agreement) {
  const devicesList = [];
  if (agreement.device || agreement.Device) devicesList.push(agreement.deviceName || agreement['Device Name'] || 'Device');
  if (agreement.portableCharger || agreement['Portable Charger']) devicesList.push('Portable Charger');
  if (agreement.protectiveCover || agreement['Protective Cover']) devicesList.push('Protective Cover');
  if (agreement.keyboard || agreement['Keyboard/Accessory']) devicesList.push('Keyboard/Accessory');
  
  const name = agreement.name || agreement.Name || '';
  const title = agreement.title || agreement.Title || '';
  const workerId = agreement.workerId || agreement['Worker ID'] || '';
  const hasDifferentTrainingId = agreement.hasDifferentTrainingId || agreement['Has Different Training ID'];
  const trainingWorkerId = agreement.trainingWorkerId || agreement['Training Worker ID'] || '';
  const serialNumber = agreement.serialNumber || agreement['Serial Number'] || '';
  const esperIdentifier = agreement.esperIdentifier || agreement['Esper Identifier Code'] || '';
  const exchangeDevice = agreement.exchangeDevice || agreement['Exchange Device'];
  const returningDeviceName = agreement.returningDeviceName || agreement['Returning Device Name'] || '';
  const returningSerial = agreement.returningSerial || agreement['Returning Serial Number'] || '';
  const employeeSignature = agreement.employeeSignature || agreement['Employee Signature'] || '';
  const employeeSignatureDate = agreement.employeeSignatureDate || agreement['Employee Signature Date'];
  const supervisorSignature = agreement.supervisorSignature || agreement['Supervisor Signature'] || '';
  const supervisorSignatureDate = agreement.supervisorSignatureDate || agreement['Supervisor Signature Date'];
  
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        body {
          font-family: Arial, sans-serif;
          padding: 30px;
          color: #333;
          font-size: 12px;
        }
        .header {
          text-align: center;
          margin-bottom: 20px;
        }
        .company-info {
          text-align: center;
          font-size: 11px;
          margin-top: 8px;
        }
        .title {
          font-size: 18px;
          font-weight: bold;
          margin: 15px 0;
          color: #3E0E30;
        }
        .field {
          margin: 10px 0;
        }
        .field-label {
          font-weight: bold;
          color: #3E0E30;
        }
        .signature-section {
          margin-top: 25px;
        }
        .signatures-row {
          display: flex;
          gap: 30px;
        }
        .signature-box {
          flex: 1;
          padding: 8px 0;
        }
        .signature-label {
          font-weight: bold;
          margin-bottom: 5px;
        }
        .signature-line {
          border-bottom: 1px solid #333;
          min-height: 50px;
          margin-bottom: 5px;
        }
        .signature-line img {
          max-height: 48px;
        }
        .signature-date {
          font-size: 11px;
        }
        .footer {
          margin-top: 20px;
          text-align: center;
          font-size: 10px;
          color: #666;
        }
      </style>
    </head>
    <body>
      <div class="header">
        <h1 style="margin: 0; font-size: 20px;">PROPERTY AGREEMENT FORM</h1>
        <div class="company-info">
          <div>${CONFIG.COMPANY_INFO.name}</div>
          <div>${CONFIG.COMPANY_INFO.address}</div>
          <div>${CONFIG.COMPANY_INFO.city}</div>
          <div>${CONFIG.COMPANY_INFO.phone}</div>
        </div>
      </div>
      
      <div class="field">
        <span class="field-label">Name:</span> ${name}
      </div>
      
      <div class="field">
        <span class="field-label">Title:</span> ${title}
      </div>
      
      <div class="field">
        <span class="field-label">Worker ID:</span> ${workerId}
      </div>
      
      ${hasDifferentTrainingId ? `
      <div class="field">
        <span class="field-label">Training Worker ID:</span> ${trainingWorkerId}
      </div>
      ` : ''}
      
      <div class="title">Acknowledgement of Received Property</div>
      
      <div class="field">
        <span class="field-label">Devices Received:</span>
        <ul style="margin: 5px 0 5px 20px; padding: 0;">
          ${devicesList.map(device => `<li>${device}</li>`).join('')}
        </ul>
      </div>
      
      ${serialNumber ? `
      <div class="field">
        <span class="field-label">Serial Number:</span> ${serialNumber}
      </div>
      ` : ''}
      
      ${esperIdentifier ? `
      <div class="field">
        <span class="field-label">Esper Identifier Code:</span> ${esperIdentifier}
      </div>
      ` : ''}
      
      ${exchangeDevice ? `
      <div class="field">
        <span class="field-label">Exchange Information:</span>
        <div style="margin-left: 10px;">Returning Device: ${returningDeviceName}</div>
        <div style="margin-left: 10px;">Returning Serial: ${returningSerial}</div>
      </div>
      ` : ''}
      
      <div class="title">Agreements</div>
      
      <div class="field" style="font-size: 11px;">
         I agree to maintain all Agency property in working condition, and to notify the Agency in the event that the property malfunctions in any way, or if the property is lost or stolen.
      </div>
      
      <div class="field" style="font-size: 11px;">
         If there are any items which I do not need, these will be returned immediately to my Supervisor.
      </div>
      
      <div class="field" style="font-size: 11px;">
         I have been advised by my Supervisor / Human Resources, that it is my responsibility to return all property to the Agency upon termination of the engagement between myself and the Agency.
      </div>
      
      <div class="signature-section">
        <div class="signatures-row">
          <div class="signature-box">
            <div class="signature-label">Employee Signature</div>
            <div class="signature-line">
              ${employeeSignature ? `<img src="${svgToDataUrl(employeeSignature)}" />` : ''}
            </div>
            <div class="signature-date">Date: ${formatDate(employeeSignatureDate)}</div>
          </div>
          <div class="signature-box">
            <div class="signature-label">Supervisor Signature</div>
            <div class="signature-line">
              ${supervisorSignature ? `<img src="${svgToDataUrl(supervisorSignature)}" />` : ''}
            </div>
            <div class="signature-date">Date: ${formatDate(supervisorSignatureDate)}</div>
          </div>
        </div>
      </div>
      
      <div class="footer">
        Generated on ${formatDate(new Date())}
      </div>
    </body>
    </html>
  `;
}

function svgToDataUrl(svgPath) {
  if (!svgPath || svgPath.trim() === '') return '';
  
  const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 100">
    <path d="${svgPath}" stroke="#000" stroke-width="2" fill="none" />
  </svg>`;
  
  return 'data:image/svg+xml;base64,' + Utilities.base64Encode(svg);
}

function formatDate(date) {
  if (!date) return '';
  const d = new Date(date);
  return `${d.getMonth() + 1}/${d.getDate()}/${d.getFullYear()}`;
}

// ============================================
// HTML TEMPLATES (Placeholder - Frontend to be built)
// ============================================

function getFormPage() {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <title>Property Agreement Form</title>
      <style>
        body { font-family: Arial; padding: 20px; text-align: center; }
      </style>
    </head>
    <body>
      <h1>Property Agreement Form</h1>
      <p>This is a placeholder. Build your frontend to connect to this endpoint.</p>
      <p>Web App URL: ${ScriptApp.getService().getUrl()}</p>
      <p>Use POST requests with action parameter to interact with the backend.</p>
    </body>
    </html>
  `;
}

function getAdminLoginPage() {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <title>Admin Login</title>
      <style>
        body { font-family: Arial; padding: 20px; text-align: center; }
      </style>
    </head>
    <body>
      <h1>Admin Portal</h1>
      <p>This is a placeholder. Build your admin frontend to connect to this endpoint.</p>
      <p>Web App URL: ${ScriptApp.getService().getUrl()}</p>
    </body>
    </html>
  `;
}

// ============================================
// UTILITY FUNCTIONS FOR TESTING
// ============================================

function testSubmit() {
  const testData = {
    action: 'submitForm',
    name: 'John Doe',
    title: 'RN  Registered Nurse',
    workerId: '12345',
    hasDifferentTrainingId: false,
    trainingWorkerId: '12345',
    device: true,
    deviceName: 'Lenovo Tab',
    portableCharger: true,
    protectiveCover: true,
    keyboard: false,
    serialNumber: 'SN123456',
    esperIdentifier: 'ESP789',
    exchangeDevice: false,
    agreement1: true,
    agreement2: true,
    agreement3: true,
    employeeSignatureDate: new Date(),
    employeeSignature: 'M 10 50 L 100 50',
    supervisorSignatureDate: new Date(),
    supervisorSignature: 'M 10 50 L 100 50',
    sendCopyToEmployee: true,
    employeeEmail: 'john.doe@example.com'
  };
  
  Logger.log(submitAgreement(testData));
}

function testGetAgreements() {
  Logger.log(getAllAgreements());
}

function testSearch() {
  Logger.log(searchAgreements('john'));
}

function testStats() {
  Logger.log(getStatistics());
}

// Test email sending directly (run this to verify emails work)
function testEmailSending() {
  Logger.log('=== EMAIL TEST STARTED ===');
  Logger.log('Admin emails configured: ' + JSON.stringify(CONFIG.ADMIN_EMAILS));
  
  // Check remaining email quota
  const remainingQuota = MailApp.getRemainingDailyQuota();
  Logger.log('Remaining daily email quota: ' + remainingQuota);
  
  if (remainingQuota <= 0) {
    Logger.log('ERROR: No email quota remaining!');
    return;
  }
  
  const testData = {
    name: 'TEST - Email Test',
    title: 'Test Title',
    workerId: '00000',
    device: true,
    deviceName: 'Test Device',
    portableCharger: false,
    protectiveCover: false,
    keyboard: false,
    serialNumber: 'TEST-SERIAL',
    esperIdentifier: 'TEST-ESPER',
    exchangeDevice: false,
    employeeSignature: 'M 10 50 L 100 50 L 150 30',
    employeeSignatureDate: new Date(),
    supervisorSignature: 'M 10 50 L 100 50 L 150 70',
    supervisorSignatureDate: new Date()
  };
  
  try {
    sendNotificationEmails(testData, 0);
    Logger.log('=== EMAIL TEST COMPLETED ===');
    Logger.log('Check your inbox at: ' + CONFIG.ADMIN_EMAILS.join(', '));
  } catch(e) {
    Logger.log('=== EMAIL TEST FAILED ===');
    Logger.log('Error: ' + e.message);
    Logger.log('Stack: ' + e.stack);
  }
}

// Test provisioning functions
function testMarkProvisioned() {
  Logger.log('=== PROVISIONING TEST ===');
  
  // Get the last row number for testing
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(CONFIG.SHEET_NAME);
  if (!sheet) {
    Logger.log('Sheet not found');
    return;
  }
  
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) {
    Logger.log('No data rows to test with');
    return;
  }
  
  // Test marking as provisioned
  Logger.log('Marking row ' + lastRow + ' as provisioned...');
  const result = markDeviceProvisioned(lastRow, true);
  Logger.log('Result: ' + JSON.stringify(result));
  
  // Test getting provisioned devices
  Logger.log('Getting provisioned devices...');
  const devices = getProvisionedDevices();
  Logger.log('Provisioned devices: ' + JSON.stringify(devices));
}

// Test due for return functions
function testMarkDueForReturn() {
  Logger.log('=== DUE FOR RETURN TEST ===');
  
  // Get the last row number for testing
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(CONFIG.SHEET_NAME);
  if (!sheet) {
    Logger.log('Sheet not found');
    return;
  }
  
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) {
    Logger.log('No data rows to test with');
    return;
  }
  
  // Test marking as due for return
  Logger.log('Marking row ' + lastRow + ' as due for return...');
  const result = markDueForReturn(lastRow, true);
  Logger.log('Result: ' + JSON.stringify(result));
  
  // Test getting due for return devices
  Logger.log('Getting due for return devices...');
  const devices = getDueForReturnDevices();
  Logger.log('Due for return devices: ' + JSON.stringify(devices));
  
  // Test unmarking
  Logger.log('Unmarking row ' + lastRow + ' as due for return...');
  const unmarkResult = markDueForReturn(lastRow, false);
  Logger.log('Unmark result: ' + JSON.stringify(unmarkResult));
}

/**
 * Migration utility: Add Provisioned column to existing spreadsheet
 * Run this once if you have an existing spreadsheet without the Provisioned column
 */
function addProvisionedColumn() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(CONFIG.SHEET_NAME);
  if (!sheet) {
    Logger.log('Sheet not found');
    return;
  }
  
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  if (headers.indexOf('Provisioned') !== -1) {
    Logger.log('Provisioned column already exists');
    return;
  }
  
  // Add the header
  const newColIndex = headers.length + 1;
  sheet.getRange(1, newColIndex).setValue('Provisioned');
  
  // Set all existing rows to FALSE
  const lastRow = sheet.getLastRow();
  if (lastRow > 1) {
    const range = sheet.getRange(2, newColIndex, lastRow - 1, 1);
    const values = [];
    for (let i = 0; i < lastRow - 1; i++) {
      values.push([false]);
    }
    range.setValues(values);
  }
  
  Logger.log('Provisioned column added successfully');
}

/**
 * Migration utility: Add DueForReturn column to existing spreadsheet
 * Run this once if you have an existing spreadsheet without the DueForReturn column
 */
function addDueForReturnColumn() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(CONFIG.SHEET_NAME);
  if (!sheet) {
    Logger.log('Sheet not found');
    return;
  }
  
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  if (headers.indexOf('DueForReturn') !== -1) {
    Logger.log('DueForReturn column already exists');
    return;
  }
  
  // Add the header
  const newColIndex = headers.length + 1;
  sheet.getRange(1, newColIndex).setValue('DueForReturn');
  
  // Set all existing rows to FALSE
  const lastRow = sheet.getLastRow();
  if (lastRow > 1) {
    const range = sheet.getRange(2, newColIndex, lastRow - 1, 1);
    const values = [];
    for (let i = 0; i < lastRow - 1; i++) {
      values.push([false]);
    }
    range.setValues(values);
  }
  
  Logger.log('DueForReturn column added successfully');
}

/**
 * Migration utility: Add all missing columns to existing spreadsheet
 * Run this once to ensure all required columns exist
 */
function addAllMissingColumns() {
  Logger.log('=== Adding all missing columns ===');
  addProvisionedColumn();
  addDueForReturnColumn();
  Logger.log('=== Migration complete ===');
}